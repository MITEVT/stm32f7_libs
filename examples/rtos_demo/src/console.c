#include "console.h"

#include <string.h>
#include <stdio.h>

#include "board.h"

#include "stm32f7xx_hal_conf.h"

#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "FreeRTOS_CLI.h"
#include "task.h"

/*-----------------------------------------------------------*/
/* private variable declaration */

static BaseType_t prvToggleLEDCommand(char*, size_t, const char*);
static BaseType_t prvFreqCommand(char*, size_t, const char*);
static BaseType_t prvRandomCommand(char*, size_t, const char*);
static BaseType_t prvSampleADC(char*, size_t, const char*);
static BaseType_t prvSystemReset(char*, size_t, const char*);
static BaseType_t prvDMATest(char*, size_t, const char*);

static const CLI_Command_Definition_t xToggleLEDCommand = {
    "toggle-led",
    "toggle-led <num>: Toggle LED<num>\r\n",
    prvToggleLEDCommand,
    1
};

static const CLI_Command_Definition_t xFreqCommand = {
    "freq",
    "freq: Get CPU Frequency\r\n",
    prvFreqCommand,
    0
};

static const CLI_Command_Definition_t xRandomCommand = {
    "random",
    "random [n]: Get [n] Randomly Generated Number\r\n",
    prvRandomCommand,
    1
};

static const CLI_Command_Definition_t xSampleADCCommand = {
    "adc",
    "adc: Sample from A0\r\n",
    prvSampleADC,
    0
};

static const CLI_Command_Definition_t xSystemReset = {
    "reset",
    "reset: Perform a software reset\r\n",
    prvSystemReset,
    0
};

static const CLI_Command_Definition_t xDMATest = {
    "dma-test",
    "dma-test: Perform a memory-memory dma test",
    prvDMATest,
    0
};

static RNG_HandleTypeDef *xRNG;
static ADC_HandleTypeDef *xADC;
static DMA_HandleTypeDef *xDMA;

/*-----------------------------------------------------------*/
/* utility function prototypes */

static int32_t atoi(char *s);
static char* itoa(int value, char* buffer, int base);

/*-----------------------------------------------------------*/
/* private variables */

#define ADC_TIMEOUT 1

#define DMA_TEST_SIZE 64
static volatile uint32_t dma_dest[DMA_TEST_SIZE];


/*-----------------------------------------------------------*/
/* console initialization function */

void vConsoleInit(RNG_HandleTypeDef *rng, ADC_HandleTypeDef *adc, DMA_HandleTypeDef *dma) {
    FreeRTOS_CLIRegisterCommand(&xToggleLEDCommand);
    FreeRTOS_CLIRegisterCommand(&xFreqCommand);
    FreeRTOS_CLIRegisterCommand(&xRandomCommand);
    FreeRTOS_CLIRegisterCommand(&xSampleADCCommand);
    FreeRTOS_CLIRegisterCommand(&xSystemReset);
    FreeRTOS_CLIRegisterCommand(&xDMATest);

    xRNG = rng;
    xADC = adc;
    xDMA = dma;
}

/*-----------------------------------------------------------*/
/* main task function */

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

#define CALC_UART_TIMEOUT(n) (n*1000*2/UART_BAUD + 10)

static const char* const pcWelcomeMessage =
  "\r\n***************************************************\r\n \
   \t\tFreeRTOS command server.\r\nType 'help' to view a list of registered commands.\r\n>";

static char *pcNewLine = "\r\n";

static const char* const pcBackSpace = "\033[1D \033[1D";
void vCommandConsoleTask( void *pvParameters )
{
	UART_HandleTypeDef *xConsole;

	uint8_t cRxedChar = 0;
	int8_t cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static char pcOutputString[MAX_OUTPUT_LENGTH], pcInputString[MAX_INPUT_LENGTH];

    /* This code assumes the peripheral being used as the console has already
    been opened and configured, and is passed into the task as the task
    parameter.  Cast the task parameter to the correct type. */
    xConsole = (UART_HandleTypeDef*) pvParameters;

    /* Send a welcome message to the user knows they are connected. */
    HAL_UART_Transmit(xConsole, (uint8_t*)pcWelcomeMessage, strlen(pcWelcomeMessage), CALC_UART_TIMEOUT(strlen(pcWelcomeMessage)));

    uint8_t nl_flag = 0;

    for( ;; )
    {
        /* This implementation reads a single character at a time. Yield if no character available */
 		while(HAL_UART_Receive(xConsole, &cRxedChar, 1, 1) != HAL_OK) {
 			vTaskDelay(1 / portTICK_PERIOD_MS);
 		}

        if((cRxedChar == '\n' || cRxedChar == '\r') && nl_flag == 0) {
        	nl_flag = 1; // Last character received was a new line 

            /* A newline character was received, so the input command string is
            complete and can be processed.  Transmit a line separator, just to
            make the output easier to read. */
    		HAL_UART_Transmit(xConsole, (uint8_t*)pcNewLine, strlen(pcNewLine), CALC_UART_TIMEOUT(strlen(pcNewLine)));

            /* The command interpreter is called repeatedly until it returns
            pdFALSE.  See the "Implementing a command" documentation for an
            explanation of why this is. */
            if (cInputIndex != 0) {
	            do {
	                /* Send the command string to the command interpreter.  Any
	                output generated by the command interpreter will be placed in the
	                pcOutputString buffer. */
	                xMoreDataToFollow = FreeRTOS_CLIProcessCommand
	                              (
	                                  pcInputString,   /* The command string.*/
	                                  pcOutputString,  /* The output buffer. */
	                                  MAX_OUTPUT_LENGTH/* The size of the output buffer. */
	                              );

	                /* Write the output generated by the command interpreter to the
	                console. */
	                
				    HAL_UART_Transmit(xConsole, (uint8_t*)pcOutputString, strlen(pcOutputString), CALC_UART_TIMEOUT(strlen(pcOutputString)));
                    memset(pcOutputString, 0, MAX_OUTPUT_LENGTH);
	            } while(xMoreDataToFollow != pdFALSE);
	            cInputIndex = 0;
            	memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
            	pcOutputString[0] = 0x00;
	        }

            /* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready
            to receive the next command. */
			HAL_UART_Transmit(xConsole, (uint8_t*)">", 1, CALC_UART_TIMEOUT(1));
        }
        else
        {
            /* The if() clause performs the processing after a newline character
            is received.  This else clause performs the processing if any other
            character is received. */

            if (cRxedChar == '\r' || cRxedChar == '\n') {
                /* Ignore new line characters */
            } else if (cRxedChar == '\b' || cRxedChar == 0x7F) {
                /* Backspace was pressed.  Erase the last character in the input
                buffer - if there are any. */
                if (cInputIndex > 0) {
                    cInputIndex--;
                    pcInputString[ cInputIndex ] = '\0';
    				HAL_UART_Transmit(xConsole, (uint8_t*)pcBackSpace, strlen(pcBackSpace), CALC_UART_TIMEOUT(strlen(pcBackSpace)));
                }
                nl_flag = 0;
            } else {
                /* A character was entered.  It was not a new line, backspace
                or carriage return, so it is accepted as part of the input and
                placed into the input buffer.  When a \n is entered the complete
                string will be passed to the command interpreter. */
                if (cInputIndex < MAX_INPUT_LENGTH) {
                    pcInputString[ cInputIndex ] = cRxedChar;
                    cInputIndex++;
    				HAL_UART_Transmit(xConsole, &cRxedChar, 1, CALC_UART_TIMEOUT(1));
                }
                nl_flag = 0;
            }
        }
    }
}
			

/*-----------------------------------------------------------*/
/* toggle LED callback */

static const char* const pcToggleLEDErrorMessage =
  "Error during toggle\r\n\r\n";

/* This function implements the behavior of a command, so must have the correct
prototype. */
static BaseType_t prvToggleLEDCommand(char *pcWriteBuffer,
                                     size_t xWriteBufferLen,
                                     const char *pcCommandString) {
	char* pcParameter1;
	BaseType_t xParameter1StringLength, xResult;

    /* Obtain the name of the led, and the length of its name, from
    the command string. The name of the led is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter(
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
                          &xParameter1StringLength
                        );

    /* Terminate the parameter. */
    pcParameter1[xParameter1StringLength] = 0x00;

    /* Perform the toggle operation itself. */
    xResult = pdPASS;
    if (strlen(pcParameter1) > 1) xResult = pdFAIL;
    else if (pcParameter1[0] == '2') boardTOGGLE_LED2();
    else if (pcParameter1[0] == '3') boardTOGGLE_LED3();
    else xResult = pdFAIL;

    if(xResult != pdPASS)
    {
        /* The toggle was unsuccessful.  Output Error message. */
    	if (xWriteBufferLen < strlen(pcToggleLEDErrorMessage)) {
    		memcpy(pcWriteBuffer, pcToggleLEDErrorMessage, xWriteBufferLen);
    		return pdTRUE;
    	} else {
    		memcpy(pcWriteBuffer, pcToggleLEDErrorMessage, strlen(pcToggleLEDErrorMessage));
    	}
    }

    /* There is only a single line of output produced in all cases.  pdFALSE is
    returned because there is no more output to be generated. */
    return pdFALSE;
}

/*-----------------------------------------------------------*/
/* get CPU freq callback */

static const char* const pcFreqStartMessage =
  "CPU Clock Frequency: ";
static const char* const pcFreqEndMessage = 
  " Mhz\r\n";

static BaseType_t prvFreqCommand(char *pcWriteBuffer,
                                     size_t xWriteBufferLen,
                                     const char *pcCommandString) {

	(void)xWriteBufferLen;
	(void)pcCommandString;

	char str[5];
    itoa(SystemCoreClock/1000000, str, 10);

    memcpy(pcWriteBuffer, pcFreqStartMessage, strlen(pcFreqStartMessage));
    memcpy(pcWriteBuffer + strlen(pcFreqStartMessage), str, strlen(str));
    memcpy(pcWriteBuffer + strlen(pcFreqStartMessage) + strlen(str), pcFreqEndMessage, strlen(pcFreqEndMessage));

    /* There is only a single line of output produced in all cases.  pdFALSE is
    returned because there is no more output to be generated. */
    return pdFALSE;
}

/*-----------------------------------------------------------*/
/* Get random number callback */

static const char* const pcRandomErrorMessage =
    "Error: Invalid number\r\n\r\n";

static const char* const pcRandomHardwareErrorMessage =
    "Error: Hardware Problem\r\n\r\n";

static const char* const pcRandomEndMessage = 
    "\r\n";

static uint8_t puRandomNumLeft = 0;

/* This function implements the behavior of a command, so must have the correct
prototype. */
static BaseType_t prvRandomCommand(char *pcWriteBuffer,
                                     size_t xWriteBufferLen,
                                     const char *pcCommandString) {

    BaseType_t xResult = pdPASS;

    if (puRandomNumLeft == 0) {
        const char *pcParameter1;
        BaseType_t xParameter1StringLength;

        /* Check if there are any parameters in the command string. 
        The first parameter, if present, will be the number of numbers to print. */
        pcParameter1 = FreeRTOS_CLIGetParameter(
                              pcCommandString,
                              1,
                              &xParameter1StringLength);

        puRandomNumLeft = 1;
        if(pcParameter1 != NULL) {
            char *tmp = (char *)pvPortMalloc(xParameter1StringLength + 1);
            memcpy(tmp, pcParameter1, xParameter1StringLength * sizeof(char));
            tmp[xParameter1StringLength] = 0x00;
            puRandomNumLeft = atoi(tmp);
            if (puRandomNumLeft == 0) xResult = pdFAIL;
            vPortFree(tmp);
        }
    }


    if(xResult != pdPASS) {
        /* The num was invalid.  Output Error message. (Assume Buffer long enough). */
        memcpy(pcWriteBuffer, pcRandomErrorMessage, strlen(pcRandomErrorMessage));
        return pdFALSE;
    }

    uint32_t uTotalLength = 0;
    while (puRandomNumLeft > 0) {
        char str[13];
        uint32_t n;

        HAL_StatusTypeDef xGenResult = HAL_RNG_GenerateRandomNumber(xRNG, &n);
        if (xGenResult == HAL_ERROR) {
            /* RNG Error.  Output Error message. (Assume Buffer long enough). */
            memcpy(pcWriteBuffer, pcRandomHardwareErrorMessage, strlen(pcRandomHardwareErrorMessage));
            return pdFALSE;
        }
        itoa(n, str, 10);

        uint8_t xStringLength = strlen(str);
        str[xStringLength] = '\r'; // Append newline
        str[xStringLength + 1] = '\n';
        str[xStringLength + 2] = 0x00;
        xStringLength += 2;

        uint32_t uNewLength = uTotalLength + xStringLength + ((puRandomNumLeft == 1) ? strlen(pcRandomEndMessage) : 0);

        if (xWriteBufferLen < uNewLength) {
            return pdTRUE;
        }

        memcpy(pcWriteBuffer + uTotalLength, str, xStringLength);

        puRandomNumLeft--;
        uTotalLength += xStringLength;
        if (puRandomNumLeft == 0) memcpy(pcWriteBuffer + uTotalLength + xStringLength, pcRandomEndMessage, strlen(pcRandomEndMessage));
    }

    /* pdFALSE is returned because there is no more 
    output to be generated. */
    return pdFALSE;
}

/*-----------------------------------------------------------*/

static const char* const pcSampleADCEndMessage = 
    "\r\n";

static const char* const pcSampleADCErrorMessage =
    "Error During Sample\r\n";

static const char* const pcSampleADCTimeoutMessage =
    "ADC Timeout\r\n";

static BaseType_t prvSampleADC(char *pcWriteBuffer,
                                    size_t xWriteBufferLen,
                                    const char *pcCommandString) {

    (void)xWriteBufferLen;
    (void)pcCommandString;

    char str[4];

    HAL_ADC_Start(xADC);
    HAL_StatusTypeDef status = HAL_ADC_PollForConversion(xADC, ADC_TIMEOUT);
    if (status == HAL_ERROR) {
        memcpy(pcWriteBuffer, pcSampleADCErrorMessage, strlen(pcSampleADCErrorMessage));
    } else if (status == HAL_TIMEOUT) {
        memcpy(pcWriteBuffer, pcSampleADCTimeoutMessage, strlen(pcSampleADCTimeoutMessage));
    } else {
        itoa(HAL_ADC_GetValue(xADC), str, 10);
        memcpy(pcWriteBuffer, str, strlen(str));
        memcpy(pcWriteBuffer+strlen(str), pcSampleADCEndMessage, strlen(pcSampleADCEndMessage));
    }

    return pdFALSE;
}

/*-----------------------------------------------------------*/

static BaseType_t prvSystemReset(char *pcWriteBuffer,
                                    size_t xWriteBufferLen,
                                    const char *pcCommandString) {

    (void)pcWriteBuffer;
    (void)xWriteBufferLen;
    (void)pcCommandString;

    NVIC_SystemReset();

    return pdFALSE;
}

/*-----------------------------------------------------------*/

static const char* const pcDMATestErrorMessage =
    ": Error During DMA\r\n";

static const char* const pcDMATestTimeoutMessage =
    "DMA Timeout\r\n";

static const char* const pcDMATestPassMessage = 
    "DMA Passed\r\n";

static const char* const pcDMATestFailMessage =
    "DMA Failed\r\n";

static const uint32_t pcDMATestString[6] = 
    {12, 36, 42, 33, 445, 543};

// Todo don't wait forever, just check and if not ready then return pdTrue!
static BaseType_t prvDMATest(char *pcWriteBuffer,
                                    size_t xWriteBufferLen,
                                    const char *pcCommandString) {

    (void)xWriteBufferLen;
    (void)pcCommandString;

    int i;

    HAL_DMA_Start(xDMA, pcDMATestString, dma_dest, 6);
    HAL_StatusTypeDef status = HAL_DMA_PollForTransfer(xDMA, HAL_DMA_FULL_TRANSFER, 1);
    if (status == HAL_ERROR) {
        uint32_t err = HAL_DMA_GetError(xDMA);
        uint8_t str[10];
        itoa(err, str, 16);
        memcpy(pcWriteBuffer, str, strlen(str));
        memcpy(pcWriteBuffer+strlen(str), pcDMATestErrorMessage, strlen(pcDMATestErrorMessage));
    } else if (status == HAL_TIMEOUT) {
        memcpy(pcWriteBuffer, pcDMATestTimeoutMessage, strlen(pcDMATestTimeoutMessage));
    } else {
        for (i = 0; i < 6; i++) {
            if (dma_dest[i] != pcDMATestString[i]) {
                memcpy(pcWriteBuffer, pcDMATestFailMessage, strlen(pcDMATestFailMessage));
                return pdFALSE;
            }
        }
        memcpy(pcWriteBuffer, pcDMATestPassMessage, strlen(pcDMATestPassMessage));
    }

    return pdFALSE;
}

/*-----------------------------------------------------------*/
/* Utility Functions */

static int32_t atoi(char *s) {
    int i,num=0,sign=1;

    for(i=0;s[i];i++) {
        if(s[i]==' ')
                continue;
        else if(s[i]=='-') sign=-1;
        else break;
    }
        
    for(;s[i] && s[i]>='0' && s[i]<='9';i++)
            num=num*10 + s[i]-'0';
    return num*sign;
}

// inline function to swap two numbers
static inline void swap(char *x, char *y) {
    char t = *x; *x = *y; *y = t;
}

// function to reverse buffer[i..j]
static char* reverse(char *buffer, int i, int j)
{
    while (i < j)
        swap(&buffer[i++], &buffer[j--]);

    return buffer;
}

// Iterative function to implement itoa() function in C
static char* itoa(int value, char* buffer, int base) {
    // invalid input
    if (base < 2 || base > 32)
        return buffer;

    // consider absolute value of number
    int n = (value < 0) ? value * -1 : value;
    // if (n< 0) n *= -1;
    // int n = abs(value);

    int i = 0;
    while (n) {
        int r = n % base;

        if (r >= 10) 
            buffer[i++] = 65 + (r - 10);
        else
            buffer[i++] = 48 + r;

        n = n / base;
    }

    // if number is 0
    if (i == 0)
        buffer[i++] = '0';

    // If base is 10 and value is negative, the resulting string 
    // is preceded with a minus sign (-)
    // With any other base, value is always considered unsigned
    if (value < 0 && base == 10)
        buffer[i++] = '-';

    buffer[i] = '\0'; // null terminate string

    // reverse the string and return it
    return reverse(buffer, 0, i - 1);
}